<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chat - Zunto</title>
    <style>
        :root {
            --black: #000000;
            --white: #FFFFFF;
            --gray-100: #F5F5F5;
            --gray-200: #E0E0E0;
            --gray-300: #BDBDBD;
            --gray-500: #757575;
            --gray-600: #616161;
            --gray-800: #212121;
            --space-4: 4px;
            --space-8: 8px;
            --space-16: 16px;
            --space-24: 24px;
            --space-32: 32px;
            --space-48: 48px;
            --border: 1px solid var(--gray-300);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
            background: var(--white);
            color: var(--black);
            line-height: 1.5;
            font-size: 15px;
        }
        
        .header {
            border-bottom: var(--border);
            background: var(--white);
        }
        
        .header-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: var(--space-16) var(--space-24);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .logo {
            font-size: 18px;
            font-weight: 600;
            color: var(--black);
            text-decoration: none;
            letter-spacing: -0.02em;
        }
        
        .connection-status {
            display: flex;
            align-items: center;
            gap: var(--space-8);
            font-size: 13px;
            color: var(--gray-600);
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--gray-300);
        }
        
        .status-dot.online {
            background: var(--black);
        }
        
        .chat-container {
            max-width: 800px;
            margin: 0 auto;
            height: calc(100vh - 65px);
            display: flex;
            flex-direction: column;
        }
        
        .messages-container {
            flex: 1;
            overflow-y: auto;
            padding: var(--space-24);
            display: flex;
            flex-direction: column;
            gap: var(--space-16);
        }
        
        .message {
            display: flex;
            flex-direction: column;
            max-width: 70%;
        }
        
        .message.sent {
            align-self: flex-end;
        }
        
        .message.received {
            align-self: flex-start;
        }
        
        .message-bubble {
            border: var(--border);
            padding: var(--space-8) var(--space-16);
            word-wrap: break-word;
        }
        
        .message.sent .message-bubble {
            background: var(--black);
            color: var(--white);
            border-color: var(--black);
        }
        
        .message.received .message-bubble {
            background: var(--white);
        }
        
        .message-image {
            max-width: 300px;
            border: var(--border);
            cursor: pointer;
        }
        
        .message-image img {
            width: 100%;
            display: block;
        }
        
        .message-file {
            border: var(--border);
            padding: var(--space-8) var(--space-16);
            display: flex;
            align-items: center;
            gap: var(--space-8);
            cursor: pointer;
        }
        
        .message-file:hover {
            background: var(--gray-100);
        }
        
        .voice-player {
            border: var(--border);
            padding: var(--space-8) var(--space-16);
            display: flex;
            align-items: center;
            gap: var(--space-8);
        }
        
        .play-btn {
            width: 32px;
            height: 32px;
            border: var(--border);
            background: var(--white);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }
        
        .play-btn:hover {
            background: var(--gray-100);
        }
        
        .waveform {
            flex: 1;
            height: 32px;
            display: flex;
            align-items: center;
            gap: 2px;
        }
        
        .waveform-bar {
            flex: 1;
            background: var(--gray-300);
            min-width: 2px;
        }
        
        .voice-duration {
            font-size: 12px;
            color: var(--gray-600);
        }
        
        .message-meta {
            font-size: 12px;
            color: var(--gray-500);
            margin-top: var(--space-4);
            padding: 0 var(--space-8);
        }
        
        .message.sent .message-meta {
            text-align: right;
        }
        
        .typing-indicator {
            font-size: 13px;
            color: var(--gray-600);
            padding: var(--space-8) var(--space-24);
            display: none;
        }
        
        .typing-indicator.show {
            display: block;
        }
        
        .input-container {
            border-top: var(--border);
            padding: var(--space-16) var(--space-24);
            background: var(--white);
        }
        
        .attachment-preview {
            display: none;
            padding: var(--space-8);
            margin-bottom: var(--space-8);
            border: var(--border);
            background: var(--gray-100);
        }
        
        .attachment-preview.show {
            display: flex;
            align-items: center;
            gap: var(--space-8);
        }
        
        .preview-image {
            width: 60px;
            height: 60px;
            border: var(--border);
            object-fit: cover;
        }
        
        .preview-info {
            flex: 1;
        }
        
        .preview-name {
            font-size: 13px;
            font-weight: 500;
        }
        
        .preview-size {
            font-size: 12px;
            color: var(--gray-600);
        }
        
        .remove-preview {
            border: none;
            background: none;
            cursor: pointer;
            font-size: 20px;
            padding: var(--space-4);
        }
        
        .input-form {
            display: flex;
            gap: var(--space-8);
            align-items: flex-end;
        }
        
        .attachment-btn {
            border: var(--border);
            background: var(--white);
            color: var(--black);
            padding: var(--space-8);
            cursor: pointer;
            font-size: 18px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .attachment-btn:hover {
            background: var(--gray-100);
        }
        
        .message-input {
            flex: 1;
            border: var(--border);
            padding: var(--space-8) var(--space-16);
            font-size: 14px;
            background: var(--white);
            color: var(--black);
            font-family: inherit;
            resize: none;
            height: 40px;
            max-height: 120px;
        }
        
        .message-input:focus {
            outline: none;
            border-color: var(--black);
        }
        
        .send-btn {
            border: var(--border);
            background: var(--black);
            color: var(--white);
            padding: var(--space-8) var(--space-24);
            font-size: 14px;
            cursor: pointer;
            border-color: var(--black);
            height: 40px;
        }
        
        .send-btn:hover:not(:disabled) {
            background: var(--gray-800);
        }
        
        .send-btn:disabled {
            background: var(--gray-300);
            border-color: var(--gray-300);
            color: var(--gray-500);
            cursor: not-allowed;
        }
        
        .recording-indicator {
            display: none;
            align-items: center;
            gap: var(--space-8);
            padding: var(--space-8) var(--space-16);
            border: var(--border);
            background: var(--gray-100);
            margin-bottom: var(--space-8);
        }
        
        .recording-indicator.show {
            display: flex;
        }
        
        .recording-dot {
            width: 8px;
            height: 8px;
            background: var(--black);
            border-radius: 50%;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        
        .recording-time {
            flex: 1;
            font-size: 14px;
        }
        
        .cancel-recording {
            border: var(--border);
            background: var(--white);
            padding: var(--space-4) var(--space-8);
            font-size: 13px;
            cursor: pointer;
        }
        
        .hidden {
            display: none;
        }
        
        .loading {
            text-align: center;
            padding: var(--space-48);
            color: var(--gray-600);
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="header-container">
            <a href="index.html" class="logo">Zunto</a>
            
            <div class="connection-status">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Connecting...</span>
            </div>
        </div>
    </header>
    
    <div class="chat-container">
        <div class="messages-container" id="messagesContainer">
            <div class="loading">Loading messages...</div>
        </div>
        
        <div class="typing-indicator" id="typingIndicator">
            <span id="typingUser"></span> is typing...
        </div>
        
        <div class="input-container">
            <div class="recording-indicator" id="recordingIndicator">
                <div class="recording-dot"></div>
                <span class="recording-time" id="recordingTime">0:00</span>
                <button class="cancel-recording" onclick="cancelRecording()">Cancel</button>
            </div>
            
            <div class="attachment-preview" id="attachmentPreview">
                <img class="preview-image" id="previewImage" style="display: none;">
                <div class="preview-info">
                    <div class="preview-name" id="previewName"></div>
                    <div class="preview-size" id="previewSize"></div>
                </div>
                <button class="remove-preview" onclick="removeAttachment()">Ã—</button>
            </div>
            
            <form class="input-form" id="messageForm">
                <input type="file" id="fileInput" accept="image/*,application/pdf,.doc,.docx" class="hidden">
                <input type="file" id="imageInput" accept="image/*" class="hidden">
                
                <button type="button" class="attachment-btn" onclick="document.getElementById('imageInput').click()">ðŸ“·</button>
                <button type="button" class="attachment-btn" onclick="document.getElementById('fileInput').click()">ðŸ“Ž</button>
                <button type="button" class="attachment-btn" id="voiceBtn" onclick="toggleVoiceRecording()">ðŸŽ¤</button>
                
                <textarea 
                    class="message-input" 
                    id="messageInput" 
                    placeholder="Type a message..."
                    rows="1"
                ></textarea>
                <button type="submit" class="send-btn" id="sendBtn" disabled>Send</button>
            </form>
        </div>
    </div>
    
    <script src="config.js"></script>
    <script>
        const messagesContainer = document.getElementById('messagesContainer');
        const messageForm = document.getElementById('messageForm');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const statusDot = document.getElementById('statusDot');
        const statusText = document.getElementById('statusText');
        const typingIndicator = document.getElementById('typingIndicator');
        const typingUser = document.getElementById('typingUser');
        const fileInput = document.getElementById('fileInput');
        const imageInput = document.getElementById('imageInput');
        const attachmentPreview = document.getElementById('attachmentPreview');
        const previewImage = document.getElementById('previewImage');
        const previewName = document.getElementById('previewName');
        const previewSize = document.getElementById('previewSize');
        const recordingIndicator = document.getElementById('recordingIndicator');
        const recordingTime = document.getElementById('recordingTime');
        
        let socket = null;
        let conversationId = null;
        let wsToken = null;
        let typingTimeout = null;
        let currentUser = null;
        let currentAttachment = null;
        let mediaRecorder = null;
        let audioChunks = [];
        let recordingStartTime = null;
        let recordingInterval = null;
        
        function getParams() {
            const params = new URLSearchParams(window.location.search);
            return {
                conversation: params.get('conversation'),
                token: params.get('token')
            };
        }
        
        function updateStatus(connected) {
            if (connected) {
                statusDot.classList.add('online');
                statusText.textContent = 'Connected';
                sendBtn.disabled = false;
            } else {
                statusDot.classList.remove('online');
                statusText.textContent = 'Disconnected';
                sendBtn.disabled = true;
            }
        }
        
        function formatTime(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit' 
            });
        }
        
        function formatBytes(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }
        
        function formatDuration(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }
        
        function renderMessage(message, isSent) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${isSent ? 'sent' : 'received'}`;
            
            let content = '';
            
            if (message.message_type === 'text') {
                content = `<div class="message-bubble">${message.content}</div>`;
            } else if (message.message_type === 'image') {
                content = `
                    <div class="message-image" onclick="window.open('${message.attachment_url}', '_blank')">
                        <img src="${message.attachment_url}" alt="Image">
                    </div>
                `;
            } else if (message.message_type === 'file') {
                const fileName = message.attachment_url.split('/').pop();
                content = `
                    <div class="message-file" onclick="window.open('${message.attachment_url}', '_blank')">
                        <span>ðŸ“Ž</span>
                        <span>${fileName}</span>
                        <span style="font-size: 12px; color: var(--gray-600);">${formatBytes(message.attachment_size || 0)}</span>
                    </div>
                `;
            } else if (message.message_type === 'voice') {
                content = `
                    <div class="voice-player">
                        <button class="play-btn" onclick="playVoice('${message.id}', '${message.attachment_url}')">â–¶</button>
                        <div class="waveform" id="waveform-${message.id}">
                            ${renderWaveform(message.waveform_data)}
                        </div>
                        <span class="voice-duration">${formatDuration(message.attachment_duration || 0)}</span>
                    </div>
                `;
            }
            
            messageDiv.innerHTML = `
                ${content}
                <div class="message-meta">${formatTime(message.created_at)}</div>
            `;
            
            return messageDiv;
        }
        
        function renderWaveform(data) {
            if (!data || !Array.isArray(data)) {
                return Array(30).fill(0).map(() => 
                    `<div class="waveform-bar" style="height: ${Math.random() * 100}%"></div>`
                ).join('');
            }
            return data.map(height => 
                `<div class="waveform-bar" style="height: ${height}%"></div>`
            ).join('');
        }
        
        function appendMessage(message, isSent) {
            const loadingDiv = messagesContainer.querySelector('.loading');
            const emptyDiv = messagesContainer.querySelector('.empty-state');
            
            if (loadingDiv) loadingDiv.remove();
            if (emptyDiv) emptyDiv.remove();
            
            const messageEl = renderMessage(message, isSent);
            messagesContainer.appendChild(messageEl);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }
        
        async function loadMessages() {
            try {
                const response = await apiRequest(API_CONFIG.CHAT.MESSAGES(conversationId));
                
                if (!response.ok) throw new Error('Failed to load messages');
                
                const data = await response.json();
                
                messagesContainer.innerHTML = '';
                
                if (data.messages.length === 0) {
                    messagesContainer.innerHTML = '<div style="text-align: center; padding: var(--space-48); color: var(--gray-600);">No messages yet. Start the conversation!</div>';
                    return;
                }
                
                data.messages.forEach(message => {
                    const isSent = message.sender.id === currentUser.id;
                    messagesContainer.appendChild(renderMessage(message, isSent));
                });
                
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            } catch (error) {
                messagesContainer.innerHTML = '<div style="text-align: center; padding: var(--space-48); color: var(--gray-600);">Failed to load messages</div>';
            }
        }
        
        function connectWebSocket() {
            const wsUrl = API_CONFIG.CHAT.WEBSOCKET(conversationId, wsToken);
            socket = new WebSocket(wsUrl);
            
            socket.onopen = () => {
                updateStatus(true);
                socket.send(JSON.stringify({
                    type: 'join',
                    conversation_id: conversationId
                }));
            };
            
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                
                if (data.type === 'message') {
                    const isSent = data.message.sender.id === currentUser.id;
                    appendMessage(data.message, isSent);
                }
                
                if (data.type === 'typing') {
                    if (data.is_typing) {
                        typingUser.textContent = data.user.username;
                        typingIndicator.classList.add('show');
                    } else {
                        typingIndicator.classList.remove('show');
                    }
                }
                
                if (data.type === 'product_unavailable') {
                    alert('This product is no longer available');
                    window.location.href = 'index.html';
                }
            };
            
            socket.onclose = (event) => {
                updateStatus(false);
                if (event.code === 4403 || event.code === 4410) {
                    window.location.href = 'index.html';
                }
            };
            
            socket.onerror = () => {
                updateStatus(false);
            };
        }
        
        async function sendMessage(content, messageType = 'text', attachmentData = null) {
            try {
                const payload = {
                    conversation_id: conversationId,
                    content: content || '[Attachment]',
                    message_type: messageType
                };
                
                if (attachmentData) {
                    payload.attachment_url = attachmentData.url;
                    payload.attachment_size = attachmentData.size;
                    payload.attachment_mime = attachmentData.mime;
                    if (attachmentData.duration) payload.attachment_duration = attachmentData.duration;
                    if (attachmentData.waveform) payload.waveform_data = attachmentData.waveform;
                }
                
                const response = await apiRequest(API_CONFIG.CHAT.SEND_MESSAGE, {
                    method: 'POST',
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Failed to send message');
                }
            } catch (error) {
                alert(error.message);
            }
        }
        
        async function uploadFile(file) {
            const formData = new FormData();
            formData.append('file', file);
            
            const response = await fetch(`${API_CONFIG.BASE_URL}/chat/upload/`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${getAuthToken()}`
                },
                body: formData
            });
            
            if (!response.ok) throw new Error('Upload failed');
            
            const data = await response.json();
            return data.url;
        }
        
        fileInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            currentAttachment = file;
            previewName.textContent = file.name;
            previewSize.textContent = formatBytes(file.size);
            previewImage.style.display = 'none';
            attachmentPreview.classList.add('show');
        });
        
        imageInput.addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            currentAttachment = file;
            previewName.textContent = file.name;
            previewSize.textContent = formatBytes(file.size);
            
            const reader = new FileReader();
            reader.onload = (e) => {
                previewImage.src = e.target.result;
                previewImage.style.display = 'block';
            };
            reader.readAsDataURL(file);
            
            attachmentPreview.classList.add('show');
        });
        
        function removeAttachment() {
            currentAttachment = null;
            attachmentPreview.classList.remove('show');
            fileInput.value = '';
            imageInput.value = '';
        }
        
        async function toggleVoiceRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
            } else {
                await startVoiceRecording();
            }
        }
        
        async function startVoiceRecording() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                mediaRecorder = new MediaRecorder(stream);
                audioChunks = [];
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    const duration = (Date.now() - recordingStartTime) / 1000;
                    
                    stream.getTracks().forEach(track => track.stop());
                    clearInterval(recordingInterval);
                    recordingIndicator.classList.remove('show');
                    messageInput.disabled = false;
                    
                    const url = await uploadFile(new File([audioBlob], 'voice.webm', { type: 'audio/webm' }));
                    
                    await sendMessage('[Voice message]', 'voice', {
                        url: url,
                        size: audioBlob.size,
                        mime: 'audio/webm',
                        duration: duration,
                        waveform: generateRandomWaveform()
                    });
                };
                
                mediaRecorder.start();
                recordingStartTime = Date.now();
                recordingIndicator.classList.add('show');
                messageInput.disabled = true;
                
                recordingInterval = setInterval(() => {
                    const elapsed = (Date.now() - recordingStartTime) / 1000;
                    recordingTime.textContent = formatDuration(elapsed);
                }, 100);
            } catch (error) {
                alert('Microphone access denied');
            }
        }
        
        function cancelRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                audioChunks = [];
            }
        }
        
        function generateRandomWaveform() {
            return Array(30).fill(0).map(() => Math.random() * 100);
        }
        
        let currentAudio = null;
        
        function playVoice(id, url) {
            if (currentAudio) {
                currentAudio.pause();
                currentAudio = null;
            }
            
            currentAudio = new Audio(url);
            currentAudio.play();
            
            currentAudio.onended = () => {
                currentAudio = null;
            };
        }
        
        function sendTypingIndicator(isTyping) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                socket.send(JSON.stringify({
                    type: 'typing',
                    conversation_id: conversationId,
                    is_typing: isTyping
                }));
            }
        }
        
        messageInput.addEventListener('input', () => {
            messageInput.style.height = 'auto';
            messageInput.style.height = messageInput.scrollHeight + 'px';
            
            sendTypingIndicator(true);
            
            if (typingTimeout) clearTimeout(typingTimeout);
            typingTimeout = setTimeout(() => {
                sendTypingIndicator(false);
            }, 2000);
        });
        
        messageForm.addEventListener('submit', async (e) => {
            e.preventDefault();
            
            const content = messageInput.value.trim();
            
            if (currentAttachment) {
                sendBtn.disabled = true;
                sendBtn.textContent = 'Uploading...';
                
                try {
                    const url = await uploadFile(currentAttachment);
                    const messageType = currentAttachment.type.startsWith('image/') ? 'image' : 'file';
                    
                    await sendMessage(content || '[Attachment]', messageType, {
                        url: url,
                        size: currentAttachment.size,
                        mime: currentAttachment.type
                    });
                    
                    removeAttachment();
                } catch (error) {
                    alert('Failed to upload file');
                }
                
                sendBtn.disabled = false;
                sendBtn.textContent = 'Send';
            } else if (content) {
                sendBtn.disabled = true;
                await sendMessage(content);
                sendBtn.disabled = false;
            }
            
            messageInput.value = '';
            messageInput.style.height = '40px';
            messageInput.focus();
            sendTypingIndicator(false);
        });
        
        async function init() {
            const user = getUserData();
            if (!user) {
                window.location.href = 'login.html';
                return;
            }
            
            currentUser = user;
            
            const params = getParams();
            conversationId = params.conversation;
            wsToken = params.token;
            
            if (!conversationId || !wsToken) {
                messagesContainer.innerHTML = '<div style="text-align: center; padding: var(--space-48); color: var(--gray-600);">Invalid conversation</div>';
                return;
            }
            
            await loadMessages();
            connectWebSocket();
        }
        
        init();
    </script>
</body>
</html>